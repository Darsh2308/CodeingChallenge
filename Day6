from typing import List, Tuple

def zero_sum_subarrays(arr: List[int]) -> List[Tuple[int, int]]:
    """
    Returns all (start_index, end_index) pairs (0-based, inclusive) of subarrays whose sum is 0.
    Time: O(n + K) where K is the number of results produced (can be O(n^2) in the worst case).
    Space: O(n) for the hashmap of prefix sums.
    """
    result: List[Tuple[int, int]] = []
    prefix_to_indices = {0: [-1]} 
    prefix = 0

    for i, x in enumerate(arr):
        prefix += x
        if prefix in prefix_to_indices:
            
            for j in prefix_to_indices[prefix]:
                result.append((j + 1, i))
            prefix_to_indices[prefix].append(i)
        else:
            prefix_to_indices[prefix] = [i]
    return result


def verify(arr: List[int], pairs: List[Tuple[int, int]]) -> bool:
    for a, b in pairs:
        if sum(arr[a:b+1]) != 0:
            return False
    return True

tests = [
    
    ("Example", [1, 2, -3, -1, 2]),
    # Test Case 1
    ("TC1", [4, -1, -3, 1, 2, -1]),
    # Test Case 2
    ("TC2", [1, 2, 3, 4]),
    # Test Case 3
    ("TC3", [0, 0, 0]),
    # Test Case 4
    ("TC4", [-3, 1, 2, -3, 4, 0]),
    # Edge Case: single zero
    ("SingleZero", [0]),
    # Edge Case: positives and negatives cancel
    ("CancelPairs", [1, -1, 2, -2, 3, -3]),
]

def run_tests():
    for name, arr in tests:
        pairs = zero_sum_subarrays(arr)
        ok = verify(arr, pairs)
        print(f"{name}: array={arr}")
        print(f"  count={len(pairs)}")
        print(f"  pairs={pairs}")
        print(f"  verified={ok}")
        print("-" * 70)

    # Large performance sanity test (do not print all pairs; just the count and first 20)
    big_arr = [1, -1, 2, -2, 3, -3] * 1000  # length 6000
    big_pairs = zero_sum_subarrays(big_arr)
    print("BIG (length=6000):")
    print(f"  count={len(big_pairs)}")
    print(f"  first_20_pairs={big_pairs[:20]}")
    print(f"  verified_first_20={verify(big_arr, big_pairs[:20])}")
    print("-" * 70)

run_tests()
